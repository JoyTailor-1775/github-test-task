{"version":3,"sources":["store/githubRepos/reposActionsTypes.js","store/githubRepos/reposActions.js","api/cachingProxy.js","api/github-api.js","store/githubRepos/reposOperations.js","configs/github.js","components/Table/Table.js","components/Table/index.js","components/SearchPanel/SearchPanel.js","components/SearchPanel/index.js","pages/ReposSearchPage.js","App.js","serviceWorker.js","store/githubRepos/reposReducers.js","store/rootModule.js","store/index.js","index.js"],"names":["getRepos","repos","type","types","payload","updateQueryRequest","params","fetchRequest","fetchError","error","fetchSuccess","changeCancelToken","token","getUsedStorage","allStrings","key","localStorage","hasOwnProperty","length","normalize","data","normalizedItems","items","map","el","name","full_name","stargazers_count","total_count","getItem","query","JSON","parse","setItem","a","normalizedData","stringifiedData","stringify","dataSize","navigator","storage","estimate","then","quota","remainingSize","removeItem","console","callEntity","page","order","BASE_QUERY","proxy","cache","axios","get","cancelToken","response","catch","exeption","isCancel","log","message","res","requestRepos","dispatch","actions","api","Object","freeze","ASC","DESC","Table","fetchApiRequest","props","onPageChange","updateQuery","onSortTable","newOrder","gitGubConfig","state","pageSize","this","columns","Header","accessor","sortable","manual","pages","Math","ceil","loading","resizable","onSortedChange","defaultPageSize","showPageSizeOptions","className","React","Component","MapDispatchToProps","reposOperations","reposActions","connect","gitHub","CancelToken","INITIAL_STATE","searchReq","SearchPanel","onChange","e","setState","target","value","onSearch","preventDefault","source","trim","onSearchCancel","cancel","onSubmit","maxLength","onClick","PureComponent","ReposSearchPage","App","Boolean","window","location","hostname","match","INITIAL_QUERY","combineReducers","newState","assign","reposReducers","middlewares","applyMiddleware","thunk","enhancer","composeWithDevTools","store","createStore","rootModule","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.4572d7c3.chunk.js","sourcesContent":["const GET_REPOS_SUCCESS = 'repos/GET_REPOS_SUCCESS';\r\nconst UPDATE_QUERY_REQUEST = 'repos/UPDATE_QUERY_REQUEST';\r\nconst FETCH_REQUEST = 'repos/FETCH_REQUEST';\r\nconst FETCH_ERROR = 'repos/FETCH_ERROR';\r\nconst FETCH_SUCCESS = 'repos/FETCH_SUCCESS';\r\nconst CHANGE_CANCEL_TOKEN = 'repos/CHANGE_CANCEL_TOKEN';\r\n\r\nexport default {\r\n  GET_REPOS_SUCCESS,\r\n  UPDATE_QUERY_REQUEST,\r\n  FETCH_REQUEST,\r\n  FETCH_ERROR,\r\n  FETCH_SUCCESS,\r\n  CHANGE_CANCEL_TOKEN,\r\n};\r\n","import types from './reposActionsTypes';\r\n\r\nconst getRepos = (repos) => ({\r\n  type: types.GET_REPOS_SUCCESS,\r\n  payload: repos,\r\n});\r\n\r\nconst updateQueryRequest = (params) => ({\r\n  type: types.UPDATE_QUERY_REQUEST,\r\n  payload: params,\r\n});\r\n\r\nconst fetchRequest = () => ({\r\n  type: types.FETCH_REQUEST,\r\n});\r\n\r\nconst fetchError = (error) => ({\r\n  type: types.FETCH_ERROR,\r\n  payload: error,\r\n});\r\n\r\nconst fetchSuccess = () => ({\r\n  type: types.FETCH_SUCCESS,\r\n});\r\n\r\nconst changeCancelToken = (token) => ({\r\n  type: types.CHANGE_CANCEL_TOKEN,\r\n  payload: token,\r\n});\r\n\r\nexport default {\r\n  getRepos,\r\n  updateQueryRequest,\r\n  fetchRequest,\r\n  fetchError,\r\n  fetchSuccess,\r\n  changeCancelToken,\r\n};\r\n","// Returns amount of available memory in the LocalStorage in bytes.\r\nconst getAvailableStorage = () => {\r\n  return navigator.storage.estimate().then(function (estimate) {\r\n    return estimate.quota;\r\n  });\r\n};\r\n\r\n// Returns amount of used memory in the LocalStorage in bytes.\r\n// For some reason, default function navigator.storage.estimate() does\r\n// not work properly here, presumably because of insecure connection\r\n// protocole (HTTP), hence I've used manual function to count , at least\r\n// approximate amount of taken memory.\r\nconst getUsedStorage = () => {\r\n  let allStrings = '';\r\n  for (const key in localStorage) {\r\n    if (localStorage.hasOwnProperty(key)) {\r\n      allStrings += localStorage[key];\r\n    }\r\n  }\r\n  return allStrings.length * 2;\r\n};\r\n\r\n// Deletes the oldest row in the LocalStorage\r\nexport const deleteTheOldestRow = () => {\r\n  localStorage.removeItem(localStorage.key(0));\r\n};\r\n\r\n// Normalizes incoming data for storing\r\nconst normalize = (data) => {\r\n  const normalizedItems = data.items.map((el) => {\r\n    return { name: el.name, full_name: el.full_name, stargazers_count: el.stargazers_count };\r\n  });\r\n  return {\r\n    total_count: data.total_count,\r\n    items: normalizedItems,\r\n  };\r\n};\r\n\r\n// Finds requested key in the LocalStorage and returns it's value\r\nexport const getItem = (query) => {\r\n  return JSON.parse(localStorage.getItem(query));\r\n};\r\n\r\nexport const setItem = async (query, data) => {\r\n  // Normalizes incoming data and preparing for stroing in JSON format.\r\n  const normalizedData = normalize(data);\r\n  const stringifiedData = JSON.stringify(normalizedData);\r\n  // In UTF-8 encoding 1 string character takes 2 bytes of memory for storing.\r\n  const dataSize = stringifiedData.length * 2;\r\n\r\n  // Here it checks if browser at all have LocalStorage manamegent tools, if not\r\n  // - proxy process exits. If browser do has all the neccessary tools - the oldest\r\n  // rows in the LocalStorage are deleted, unless there is enough space to store the\r\n  // incoming data.\r\n  try {\r\n    const remainingSize = (await getAvailableStorage()) - getUsedStorage();\r\n    while (dataSize >= remainingSize) {\r\n      deleteTheOldestRow();\r\n    }\r\n    localStorage.setItem(query, stringifiedData);\r\n  } catch (error) {\r\n    console.error('This browser does not support LocalStorage tools:', error);\r\n  }\r\n};\r\n","import axios from 'axios';\nimport * as proxy from './cachingProxy';\n\nexport const getRepos = async ({ name, page, order }, callEntity) => {\n  // Creates query, depending on incoming parameters.\n  const BASE_QUERY = `https://api.github.com/search/repositories?q=${name}&page=${\n    page + 1\n  }&per_page=30`;\n  const query = order ? `${BASE_QUERY}&sort=stars&order=${order}` : BASE_QUERY;\n\n  // Checks if there is already such value in the LocalStorage, and returns it\n  // if true.\n  try {\n    const cache = await proxy.getItem(query);\n    if (cache) return cache;\n  } catch (error) {\n    console.error('LocalStorage error: ', error);\n  }\n\n  // Requests a new data from git-hub api.\n  const res = await axios\n    .get(query, {\n      cancelToken: callEntity.token,\n    })\n    .then((response) => {\n      // Tries to save the api response into the LocalStorage, wether succeeded\n      // or not, returns new response to app.\n      try {\n        proxy.setItem(query, response.data);\n      } catch (error) {\n        console.error('LocalStorage error: ', error);\n      } finally {\n        return response.data;\n      }\n    })\n    .catch((exeption) => {\n      if (axios.isCancel(exeption)) {\n        console.log(exeption.message);\n      } else {\n        console.error('GitHub API error: ', exeption);\n      }\n    });\n\n  return res;\n};\n","import * as api from '../../api/github-api';\r\nimport actions from './reposActions';\r\n\r\nconst requestRepos = (params, cancelToken) => async (dispatch) => {\r\n  dispatch(actions.fetchRequest());\r\n\r\n  try {\r\n    const response = await api.getRepos(params, cancelToken);\r\n    dispatch(actions.getRepos(response));\r\n    dispatch(actions.fetchSuccess());\r\n  } catch (error) {\r\n    dispatch(actions.fetchError(error.message));\r\n  }\r\n};\r\n\r\nexport default {\r\n  requestRepos,\r\n};\r\n","export default Object.freeze({\r\n  ASC: 'asc',\r\n  DESC: 'desc',\r\n});\r\n","import React from 'react';\nimport ReactTable from 'react-table';\nimport { connect } from 'react-redux';\nimport 'react-table/react-table.css';\nimport { reposActions, reposOperations } from '../../store/githubRepos';\n\nimport gitGubConfig from '../../configs/github';\n\nclass Table extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      pageSize: 30,\n    };\n  }\n\n  fetchApiRequest = async () => {\n    await this.props.getRepos(this.props.query, this.props.cancelToken);\n  };\n\n  onPageChange = async (page) => {\n    await this.props.updateQuery({ page });\n    await this.fetchApiRequest();\n  };\n\n  onSortTable = async () => {\n    const newOrder =\n      this.props.query.order === gitGubConfig.DESC ? gitGubConfig.ASC : gitGubConfig.DESC;\n    await this.props.updateQuery({\n      order: newOrder,\n    });\n    if (!this.props.query.name) return;\n    await this.fetchApiRequest();\n  };\n\n  render() {\n    const { pageSize } = this.state;\n    return (\n      <div>\n        <ReactTable\n          columns={[\n            {\n              Header: 'Repository Name',\n              accessor: 'name',\n              sortable: false,\n            },\n            {\n              Header: 'Full Name',\n              accessor: 'full_name',\n              sortable: false,\n            },\n            {\n              Header: 'Stars',\n              accessor: 'stargazers_count',\n            },\n          ]}\n          manual\n          data={this.props.repos.items}\n          // GitGub api allows to get only the first 1000 results for an unauthenticated user.\n          // Hence, 1000 is hard-coded here.\n          pages={Math.ceil(\n            this.props.repos.total_count\n              ? this.props.repos.total_count < 1000\n                ? this.props.total_count / this.state.pageSize\n                : 1000 / this.state.pageSize\n              : 0,\n          )}\n          loading={this.props.loading}\n          sortable\n          resizable={false}\n          onSortedChange={this.onSortTable}\n          defaultPageSize={pageSize}\n          showPageSizeOptions={false}\n          page={this.props.query.page}\n          onPageChange={this.onPageChange}\n          className=\"-striped -highlight\"\n        />\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = (state) => ({\n  repos: state.gitHub.repos,\n  query: state.gitHub.query,\n  loading: state.gitHub.loading,\n  cancelToken: state.gitHub.cancelToken,\n});\n\nconst MapDispatchToProps = {\n  getRepos: reposOperations.requestRepos,\n  updateQuery: reposActions.updateQueryRequest,\n};\n\nexport default connect(mapStateToProps, MapDispatchToProps)(Table);\n","import Table from './Table';\r\nexport default Table;\r\n","import React, { PureComponent } from 'react';\r\nimport { connect } from 'react-redux';\r\nimport axios from 'axios';\r\nimport './search-panel.scss';\r\n\r\nimport { reposOperations, reposActions } from '../../store/githubRepos';\r\n\r\nconst cancelToken = axios.CancelToken;\r\nconst INITIAL_STATE = {\r\n  searchReq: '',\r\n};\r\nObject.freeze(INITIAL_STATE);\r\n\r\nclass SearchPanel extends PureComponent {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      searchReq: '',\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.props.changeCancelToken(cancelToken.source());\r\n  }\r\n\r\n  onChange = (e) => {\r\n    this.setState({\r\n      [e.target.name]: e.target.value,\r\n    });\r\n  };\r\n\r\n  onSearch = async (e) => {\r\n    e.preventDefault();\r\n    if (!this.state.searchReq) return;\r\n    // Creates new cancel token for a new request\r\n    this.props.changeCancelToken(cancelToken.source());\r\n    const params = {\r\n      name: this.state.searchReq.trim(),\r\n      page: 0,\r\n    };\r\n    await this.props.updateQuery(params);\r\n    await this.props.getRepos(this.props.query, this.props.cancelToken);\r\n  };\r\n\r\n  onSearchCancel = async () => {\r\n    this.setState({ ...INITIAL_STATE });\r\n    await this.props.updateQuery({\r\n      name: '',\r\n      page: 0,\r\n    });\r\n    this.props.cancelToken.cancel('Cancelled by user...');\r\n  };\r\n  render() {\r\n    return (\r\n      <form className=\"search-panel\" onSubmit={this.onSearch}>\r\n        <input\r\n          name=\"searchReq\"\r\n          className=\"search-panel__input\"\r\n          value={this.state.searchReq}\r\n          onChange={this.onChange}\r\n          maxLength=\"30\"\r\n        />\r\n        <div className=\"controls\">\r\n          <button className=\"controls__button controls__button--action\" type=\"submit\">\r\n            Search\r\n          </button>\r\n          <button\r\n            className=\"controls__button controls__button--cancel\"\r\n            type=\"reset\"\r\n            onClick={this.onSearchCancel}\r\n          >\r\n            X\r\n          </button>\r\n        </div>\r\n      </form>\r\n    );\r\n  }\r\n}\r\n\r\nconst mapStateToProps = (state) => ({\r\n  query: state.gitHub.query,\r\n  repos: state.gitHub.repos,\r\n  cancelToken: state.gitHub.cancelToken,\r\n});\r\n\r\nconst MapDispatchToProps = {\r\n  getRepos: reposOperations.requestRepos,\r\n  updateQuery: reposActions.updateQueryRequest,\r\n  changeCancelToken: reposActions.changeCancelToken,\r\n};\r\n\r\nexport default connect(mapStateToProps, MapDispatchToProps)(SearchPanel);\r\n","import SearchPanel from './SearchPanel';\r\nexport default SearchPanel;\r\n","import React from 'react';\nimport Table from '../components/Table/';\nimport SearchPanel from '../components/SearchPanel';\n\nimport './page.scss';\n\nconst ReposSearchPage = () => {\n  return (\n    <main className=\"page-content\">\n      <SearchPanel />\n      <Table />\n    </main>\n  );\n};\n\nexport default ReposSearchPage;\n","import React from 'react';\nimport './App.css';\n\nimport ReposSearchPage from './pages/ReposSearchPage';\n\nconst App = () => {\n  return <ReposSearchPage />;\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import { combineReducers } from 'redux';\r\nimport types from './reposActionsTypes';\r\n\r\nconst INITIAL_QUERY = {\r\n  name: '',\r\n  page: 0,\r\n  order: null,\r\n};\r\n\r\nfunction reposReducer(state = [], { type, payload }) {\r\n  switch (type) {\r\n    case types.GET_REPOS_SUCCESS:\r\n      return payload;\r\n\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\nfunction queryRequestReducer(state = { ...INITIAL_QUERY }, { type, payload }) {\r\n  switch (type) {\r\n    case types.UPDATE_QUERY_REQUEST:\r\n      const newState = Object.assign(state, payload);\r\n      return newState;\r\n\r\n    default:\r\n      return INITIAL_QUERY;\r\n  }\r\n}\r\n\r\nfunction loadingReducer(state = false, { type }) {\r\n  switch (type) {\r\n    case types.FETCH_REQUEST:\r\n      return true;\r\n\r\n    case types.FETCH_SUCCESS:\r\n    case types.FETCH_ERROR:\r\n      return false;\r\n\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\nfunction errorReducer(state = null, { type, payload }) {\r\n  switch (type) {\r\n    case types.FETCH_REQUEST:\r\n      return null;\r\n\r\n    case types.FETCH_ERROR:\r\n      return payload;\r\n\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\nfunction cancelToken(state = null, { type, payload }) {\r\n  switch (type) {\r\n    case types.CHANGE_CANCEL_TOKEN:\r\n      return payload;\r\n\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\nexport default combineReducers({\r\n  loading: loadingReducer,\r\n  error: errorReducer,\r\n  repos: reposReducer,\r\n  query: queryRequestReducer,\r\n  cancelToken: cancelToken,\r\n});\r\n","import { combineReducers } from 'redux';\r\nimport reposReducers from './githubRepos/reposReducers';\r\n\r\nexport default combineReducers({\r\n  gitHub: reposReducers,\r\n});\r\n","import { createStore, applyMiddleware } from 'redux';\r\nimport { composeWithDevTools } from 'redux-devtools-extension';\r\nimport thunk from 'redux-thunk';\r\n\r\nimport rootModule from './rootModule';\r\n\r\nconst middlewares = applyMiddleware(thunk);\r\nconst enhancer = composeWithDevTools(middlewares);\r\n\r\nconst store = createStore(rootModule, enhancer);\r\n\r\nexport default store;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nimport { Provider } from 'react-redux';\nimport store from './store/index';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}